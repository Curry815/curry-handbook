# 第1章 Vue简介
Vue.js最独特的特点之一就是响应式系统，数据模型仅仅时普通的JavaScript对象，而变化侦测是响应式系统的核心，变化侦测的作用是侦数据的变化，当数据变化时，会通知视图进行相应的更新。


# 第2章 Object的变化侦测
Object和Array的变化侦测是不一样的
## 2.1 什么是变化侦测
变化侦测有两种类型: "推"（push），"拉"（pull）
Angular和React中的变化侦测属于"拉"。也就是当状态发生变化时，它不知道哪个状态变了，只知道状态可能变了，然后会发送一个信号告诉框架，框架内部收到信号后，会进行一个暴力比对来找出那些DOM节点需要重新渲染。这在Angular中是脏检查的流程，在React中使用的是虚拟DOM。
而Vue.js的变化侦测是"推"。当状态发生变化时，Vue.js立即就知道了，而且在一定程度上知道哪些状态变了，因此，它知道的信息更多，也就可以进行更细粒度的更新。细粒度即一个关系绑定的依赖关系越多，每个依赖表示一个具体的DOM节点，那么当这个状态发生变化时，向这个状态的所有依赖发送通知，让它们进行DOM更新操作，它的粒度就更细。相比较而言，"拉"的粒度是最粗的。
但是细粒度也有一定的代价，因为粒度越细，每个状态所绑定的依赖就越多，依赖追踪在内存上的开销就会越大。因此，vue从2.0绑定的依赖开始不再采用具体的DOM节点，而是一个组件。这样状态变化后，会通知到组件，组件内部再使用虚拟DOM进行比对，这就大大降低依赖数量，从而降低依赖追踪所消耗的内存。
Vue之所以能随意调整粒度，因为它的变化侦测属于"推",因为"推"可以随意调整粒度。
## 2.2 如何追踪变化
在JavaScript中追踪一个对象的变化，有两种方法可以侦测到变化：使用Object.defineProperty和ES6的Proxy。
为什么Vue不用ES6呢？因为ES6在浏览器的支持度不是很理想，所以Vue还是采用Object.defineProperty来实现变化侦测的原理。
但是日后还是会采用Proxy重写Object.defineProperty的方法，因为Object.defineProperty有很多的缺陷。
### Object.defineProperty有什么缺陷？
Object.defineProperty 是 JavaScript 中用来定义对象属性的方法，它有一些缺陷和限制，其中一些包括：
1.不可枚举属性：使用 Object.defineProperty 定义的属性默认是不可枚举的，这意味着它们不会出现在 for...in 循环中，也不会被 Object.keys()、Object.values() 和 Object.entries() 等方法返回的结果中。这可能会导致一些意外行为，因为它们与对象字面量定义的属性不同。
2.不可修改已有属性：Object.defineProperty 无法修改已有属性的属性描述符。例如，你不能将一个可写的属性改为不可写，或者将一个不可枚举的属性改为可枚举。
3.严格模式下的限制：在严格模式下，尝试修改不可写属性、不可配置属性或者删除不可删除的属性时，会抛出 TypeError 错误。这可能会限制你在运行时动态地改变对象的结构。
4.兼容性问题：虽然 Object.defineProperty 是 ECMAScript 5 引入的，但在一些老旧的浏览器中可能不被支持或支持不完全，需要谨慎使用，并且需要考虑兼容性问题。
5.复杂性和易用性：使用 Object.defineProperty 来定义属性比使用对象字面量或 Object.defineProperty 方法更为复杂，特别是对于复杂的属性描述符，例如 get 和 set 方法。
6.综上所述，虽然 Object.defineProperty 提供了一种强大的方式来定义对象属性，但它也有一些限制和缺陷，需要根据具体的使用情况进行权衡和考虑。在一些情况下，你可能会选择使用其他方法来定义对象属性，例如对象字面量或者 Object.defineProperty 的替代方法。
### 为什么vue.js不适用Object.defineProperty了,而采用ES6的Proxy？
Vue.js 在早期版本中使用了 Object.defineProperty 来实现数据的响应式，但是随着技术的发展和需求的变化，Vue.js 在 2.6 版本中引入了 Proxy 对象作为数据响应式的底层实现。这是因为 Proxy 相比于 Object.defineProperty 具有一些优势：
1.更强大和灵活：Proxy 提供了更强大和灵活的拦截器机制，可以拦截对象的更多操作，包括属性的读取、赋值、删除等，以及数组的变化。这使得 Vue.js 在实现响应式时可以更加精细地控制对象的行为，而不像 Object.defineProperty 那样只能拦截属性的读取和赋值。
2.更直观和简洁：使用 Proxy 可以更直观地定义响应式行为，不需要像 Object.defineProperty 那样手动定义 getter 和 setter 函数，使代码更加简洁和易于理解。
3.更好的性能：一些基准测试表明，Proxy 比 Object.defineProperty 在一些场景下具有更好的性能，尤其是在大规模数据变化时，Proxy 的性能可能更优。
4.原生支持：Proxy 是 ECMAScript 6 中的新特性，得到了现代 JavaScript 引擎的原生支持，而 Object.defineProperty 是 ECMAScript 5 中引入的特性，可能需要通过 polyfill 或者 shim 来实现兼容性。
5.综合考虑以上因素，Vue.js 选择使用 Proxy 来实现数据的响应式，以提供更强大、更灵活、更直观和更高性能的响应式机制。
#### 什么是polyfill/shim？
Polyfill（多补丁）是指一种用于实现浏览器缺失功能的代码，特别是在老版本的浏览器中。Polyfill 通常是由 JavaScript 编写的，它会检查浏览器是否已经原生支持某个功能，如果没有，则提供一个实现该功能的代码。这样一来，开发者可以在编写代码时使用新的标准和 API，而无需担心在一些浏览器中的兼容性问题。同样地，对于一些新的 JavaScript 语法，比如箭头函数、模板字符串等，在一些老版本的浏览器中也可以使用对应的 polyfill 来实现支持。
Shim（垫片）是一种用于在旧版环境中模拟新功能或修补旧功能的代码片段或库。与 Polyfill 相似，Shim 也是为了解决浏览器兼容性问题而设计的。然而，Shim 通常用于解决的问题更为广泛，不仅仅局限于提供新功能的模拟实现。它还可以用于修复旧版本浏览器中的 bug，或者实现一些新标准中没有涉及到的功能。Shim 的实现方式可能比较灵活，可以是一小段代码片段，也可以是一个完整的库。它的主要目标是使得旧版本的浏览器能够在某种程度上支持新的功能，或者修复旧版本浏览器中的问题，而无需修改原始的代码。总的来说，Shim 是一种更通用的解决方案，用于解决旧版环境中的功能缺失、bug修复等问题，而不仅仅局限于提供新功能的模拟实现。
## 2.3 如何收集依赖
注意：在Vue2中，模板使用数据等同于组件使用数据，所以当数据发生变化时，会将通知发生到组件，然后组件内部再通过虚拟DOM重新渲染。所以，总结起来就是在getter中收集依赖，在setter中触发依赖。
## 2.4 收集依赖在哪里
收集到Dep中。
## 2.5 依赖是谁
我们收集的依赖是window.target，收集谁就是当属性变化时，通知谁。要通知的地方很多，有可能是模板有可能是watch，这时就需要抽象出一个能集中处理这些情况的类，然后，我们在依赖收集阶段只收集这个封装好的类的实例进来，通知也只通知它一个，接着，它在负责通知其他地方，所以这个抽象的东西就叫Watcher。收集Watcher即可。
## 2.6 什么是Watcher
Watcher其实是一个中介的角色，数据发生变化时通知它，然后它再通知其他地方。
关于Watcher的经典用法
// keypath
vm.$watch('a.b.c', function (newVal, oldVal) {
  // 做点什么
})
这里表示当data.a.b.c属性发生变化时，触发第二个参数中的函数。
实现这个功能大概就是。把这个Watcher实例添加到data.a.b.c属性的Dep属性中就行了，然后，当data.a.b.c的值发生变化时，通知Watcher,接着Watcher再执行参数中的这个回调函数。
## 2.7 递归侦测所有key
如果希望把数据中的所有属性（包括子属性）都侦测到，所以要封装成一个Observer类。这个类的作用是将一个数据内的所有属性（包括子属性）都转成getter/setter的形式，然后去追踪它们的变化。
定义一个Observer类，它能把一个正常的object转换成被侦测的object，然后判断数据的类型，只有Object类的数据才会调用walk将每一个属性转换成getter/setter的形式来z侦测变化。最后，在defineReactive中新增new Observer(val)来递归子属性，这样我们就可以把data中的所有属性都转换成getter/setter的形式来侦测变化。当data中的某个属性发生变化时，这个属性对应的依赖就会接受到通知，也就是说，只要我们将一个object传到Observer中，那么这个object就会变成响应式的object。
## 2.8 关于Object的问题
Vue.js追踪不到数据的变化，例如向object添加/删除属性：
Vue.js通过Object.defineproperty来将对象的key转换成getter/setter的形式来追踪变化，但getter/setter只能追踪一个数据是否被修改，无法追踪新增属性和删除属性，所以才会导致追踪不到数据的变化，因为在ES6之前，JavaScript没有提供元编程的能力，所以为了解决这个问题，Vue.js提供了两个API——vm.$set与vm.$delete。
## 2.9 总结
变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。
Object可以通过Object.defineproperty将属性转化成getter/setter的形式追踪变化。读取数据时会触发getter，修改数据时会触发setter。
我们要在getter中收集有哪些依赖使用了数据。当setter被触发时，去通知getter中收集的依赖数据发生了变化。收集依赖需要为依赖找一个储存依赖的地方，为此我们创建了Dep类，它用来收集依赖、删除依赖和向依赖发送消息等。
所谓的依赖，其实就是Watcher中介，只有Watcher触发的getter才会收集依赖，哪个Watcher触发了getter，就把哪个Watcher收集到Dep中，当数据发生变化时。会循环依赖列表，把所有的Watcher都通知一遍。
Watcher的原理是先把自己设置到全局唯一的指定位置（例如window.target），然后读取数据，因为读取了数据，所以会触发这个数据的getter。接着在getter中就会从全局唯一的那个位置读取当前正在读取数据的Watcher,并把这个Watcher收集到Dep中去。通过这个方式，Watcher可以主动去订阅任意一个数据的变化。
此外我们创建了一个Observer类，它的作用是把一个object中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测object中所有数据（包括子数据）的变化。

Data通过Observer转化成getter/setter的形式来追踪变化。
当外界通过Watcher读取数据时，会触发getter从而将Watcher添加依赖中。
当数据发生了变化时，会触发setter，从而向Dep中的依赖（Watcher）发送通知。
Warcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。

# 第3章 Array的变化侦测
首先Array的侦测方式和Object不一样，因为Array原型上的方法可以改变数组的内容。
## 3.1 如何追踪变化
Array的侦测变化可以用自定义的方法去覆盖原生的原型方法，这个方法就是拦截器。
## 3.2 拦截器
这个拦截器其实就是和Array.prototype一样的Object，里面包含的属性一摸一样，只不过这个Object中某些可以改变数组自身内容的方法是我们处理过的，例如push、pop、shift、unshift、splice、sort和reverse。
## 3.3 使用拦截器覆盖Array原型
当然，拦截器只覆盖那些响应式数组的原型即可，而将一个数据转换成响应式的，需要通过Observer，所以我们只需要在Observer中使用拦截器覆盖那些即将被转换成响应式Array类型数据的原型就好了。
__proto__其实就是Object.getPrototypeOf和Object.setPrototypeOf的早期实现，所以使用ES6的Object.setPrototypeOf来代替__proto__完全可以实现相同的效果。只是到目前为止，ES6在浏览器中的支持度并不理想。
## 3.4 将拦截器方法挂载到数组的属性上
虽然绝大多数浏览器都支持这种非标准的属性来访问原型，但并不是所有浏览器都支持！因此，我没让你需要处理不能使用__proto__的情况。
Vue的做法非常暴力，就是如果不能使用__proto__,就直接将arrayMethods身上的这些方法设置到被侦测的数组上：
## 3.5 如何收集数组的依赖
Array在getter中收集依赖，在拦截器中触发依赖。
## 3.6 依赖列表存在哪儿
Vue.js把Array的依赖存在Observer中：因为在getter中可以访问到Observer实例，同时Array拦截器中也可以访问到Observer实例。
## 3.7 收集依赖
把Dep实例保存在Observer的属性上之后，我们可以在getter中像下面这样访问并收集依赖：
## 3.8 在拦截器中获取Observer实例
因为Array拦截器是对原型的一种封装，所以可以在拦截器中访问到this（当前正在被操作的数组），而dep保存在Observer中，所以需要在this上读到Observer的实例：
当然__ob__的作用不仅仅是为了在拦截器中访问Observer实例这么简单，还可以用来标记当前value是否已经别Observer转换成了响应式数据。
也就是说，所有被侦测了变化的数据身上都会有一个__ob__属性来表示它们是响应式的。因为Observer函数就是通过__ob__属性来判断；如果value是响应式的，则直接返回__ob__；如果不是响应式的，则使用new Observer来将数据转换成响应式数据。
当value身上被标记了__ob__之后，就可以通过value.__ob__来访问Observer实例。如果是Array拦截器，因为拦截器是原型方法，所以可以直接通过this.__ob__访问Observer实例。
## 3.9 向数组的依赖发送通知
在Observer实例中拿到dep属性，然后直接发送通知即可。
## 3.10 侦测数组中元素的变化
Observer会把这个数据的所有子数据转换成响应式的。
## 3.11 侦测新增元素的变化
只要能获取新增的元素并使用Observer来侦测它们就行。
### 3.11.1 获取新增元素
想要获取新增元素，我们需要在拦截器中对数组方法的类型进行判断，如果操作数组的方法是push、unshift和splice(可以新增数组元素的方法)，则把参数中新增的元素拿过来，用Observer来侦测：
前面介绍了Observer会将自身的实例附加到value的__ob__属性上。所有被侦测了变化的数据都有一个__ob__属性，数组元素也不例外。
因此我们可以在拦截器中通过this访问到__ob__，然后调用__ob__上的observeArray方法就可以了。
## 3.12 关于Array的问题
Vue2.0有些操作数组是拦截不了的，例如this.list[0] = 2;修改舒徐中第一个元素的值时，无法侦测到数组的变化，所以不会触发re-render或watch等。或者清空数组的长度，例如this.list.length = 0;但是ES6的Proxy可以实现这一功能。具体之后再研究一下如何实现！！！
## 3.13 总结
Array追踪变化的方式和Object不一样，因为它是通过方法来改变内容的，所以我们通过创建拦截器去覆盖数组原型的方式去追踪变化。为了不污染全局Array.prototype，我们在Observer中只针对那些需要侦测变化的数组使用__proto__来覆盖原型方法，但__proto__在ES6之前并不是标准属性，不是所有浏览器都支持它。因此，针对不支持__proto__属性的浏览器，我们直接循环拦截器，把拦截器中的方法直接设置到数组身上来拦截Array.prototype上的原生方法。
Array收集依赖的方式和Object一样，都是在getter中收集，但是由于使用依赖的位置不同，数组要在拦截器中向依赖发消息，所以依赖不能像Object那样保存在defineReactive中，而是把依赖保存在了Observer实例上。
在Observer中，我们对每个侦测了变化的数据都标上印记__ob__，并把this（Observer实例）保存在__ob__上。这主要有两个作用，一方面是为了标记数据是否被侦测了变化（保证同一个数据只被侦测一次），另一方面可以很方便地通过数据去到__ob__，从而拿到Observer实例上保存的依赖，当拦截到数组发生变化时，向依赖发送通知。
除了侦测已有数据之外，当用户使用push等方法向数组中新增数据时，新增的数据也要进行变化侦测。我们使用当前操作数组的方法来进行判断，如果是push、unshift和splice方法，则从参数中将新增数据提取出来，然后使用observeArray对新增数据进行变化侦测。
由于在ES6之前，JavaScript并没有提供元编程的能力，所以对于数组类型的数据，一些语法无法追踪到变化，只能拦截原型上的方法，而无法拦截数组特有的语法，例如使用length清空数组的操作就无法拦截。
# 第4章 变化侦测相关的API实现原理
## 4.1 vm.$watch
### 4.1.1 用法
vm.$watch(expOrFn, callback, [options])
参数：
{string | Function} expOrFn
{Function | Object} callback
{Object} [options]
 {boolean} deep
 {boolean} immediate
返回值: {Function} unwatch
用法：用于观察一个表达式或computed函数在Vue.js实例上的变化，回调函数调用时，会从参数得到新数据（new value）和旧数据（old value）。表达式只接受以点分隔的路径，例如a.b.c。如果是一个比较复杂的表达式，可以用函数代替表达式。
例如：
vm.$watch('a.b.c', fuction (newVal, oldVal) {
  // 做点什么
})
vm.$watch返回一个取消观察函数，用来停止触发回调：
var unwatch = vm.$watch('a', (newVal, oldVal) => {})
// 之后取消观察
unwatch()
[options]的两个选项deep和immediate
1.deep 为了发现对象内部值的变化，可以在选项参数中指定deep: true：
vm.$watch('someObject', callback, {
  deep: true
})
vm.someObject.nestedValue = 123
// 回调函数将被触发
这里需要注意的是，监听数组的变动不需要这么做。
#### 监听数组的变动应该怎么实现？
在 JavaScript 中，监听数组变动有多种实现方式，最常见的包括：
1.使用 Proxy 对象：Proxy 是 ES6 中引入的一个特性，它提供了一种机制来代理对象的行为。通过使用 Proxy 可以监听对象的操作，包括数组的变动。当数组发生变动时，可以在 Proxy 的拦截器中捕获并进行相应处理。
let array = [1, 2, 3];
let handler = {
    set(target, property, value) {
        console.log(`${property} changed from ${target[property]} to ${value}`);
        target[property] = value;
        return true;
    }
};
let proxy = new Proxy(array, handler);
proxy[0] = 10; // 输出: "0 changed from 1 to 10"
2.使用观察者模式：可以实现一个观察者模式，即定义一个观察者对象，当数组发生变动时，通知观察者对象执行相应的操作。这种方式需要手动触发通知，相对于 Proxy 来说会更显繁琐。
class ObservableArray {
    constructor(array) {
        this.array = array;
        this.observers = [];
    }
    addObserver(observer) {
        this.observers.push(observer);
    }
    notifyObservers(index, value) {
        this.observers.forEach(observer => observer.update(index, value));
    }
    set(index, value) {
        this.array[index] = value;
        this.notifyObservers(index, value);
    }
}
let array = new ObservableArray([1, 2, 3]);
array.addObserver({
    update(index, value) {
        console.log(`${index} changed to ${value}`);
    }
});
array.set(0, 10); // 输出: "0 changed to 10"
这些方法都可以用来监听数组的变动，具体使用哪种取决于你的项目需求和偏好。通常情况下，推荐使用 Proxy 对象，因为它更简洁、更强大，且不需要手动触发通知。
