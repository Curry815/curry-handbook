# 介绍
一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。
<script setup>
// 在模板中启用 v-focus
const vFocus = {
  mounted: (el) => el.focus()
}
</script>

<template>
  <input v-focus />
</template>

假设你还未点击页面中的其他地方，那么上面这个 input 元素应该会被自动聚焦。该指令比 autofocus attribute 更有用，因为它不仅仅可以在页面加载完成后生效，还可以在 Vue 动态插入元素后生效。

---------------------------------------------------------------

在 <script setup> 中，任何以 v 开头的驼峰式命名的变量都可以被用作一个自定义指令。在上面的例子中，vFocus 即可以在模板中以 v-focus 的形式使用。

在没有使用 <script setup> 的情况下，自定义指令需要通过 directives 选项注册：

<script>
  export default {
  setup() {
    /*...*/
  },
  directives: {
    // 在模板中启用 v-focus
    focus: {
      /* ... */
    }
  }
}
</script>
将一个自定义指令全局注册到应用层级也是一种常见的做法：
<script>
  const app = createApp({})
  // 使 v-focus 在所有组件中都可用
  app.directive('focus', {
    /* ... */
  })
</script>

---------------------------------------------------------------

TIP:只有当所需功能只能通过直接的 DOM 操作来实现时，才应该使用自定义指令。其他情况下应该尽可能地使用 v-bind 这样的内置指令来声明式地使用模板，这样更高效，也对服务端渲染更友好。

---------------------------------------------------------------

# 指令钩子
一个指令的定义对象可以提供几种钩子函数（都是可选的）
<script>
  const myDirective = {
  // 在绑定元素的 attribute 前
  // 或事件监听器应用前调用
  created(el, binding, vnode, prevVnode) {
    // 下面会介绍各个参数的细节
  },
  // 在元素被插入到 DOM 前调用
  beforeMount(el, binding, vnode, prevVnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都挂载完成后调用
  mounted(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件更新前调用
  beforeUpdate(el, binding, vnode, prevVnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都更新后调用
  updated(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件卸载前调用
  beforeUnmount(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件卸载后调用
  unmounted(el, binding, vnode, prevVnode) {}
}
</script>

# 钩子参数
el：指令绑定的元素。这可以用于直接操作DOM。
binding：一个对象，包含以下属性
 - value：传递给指令的值
 - oldValue：之前的值，仅在beforeUpdate和update中可用。无论值是否更改，它都可用。
 - arg：传递给指令的参数（如果有的话）。例如在 v-my-directive:foo 中，参数是 "foo"。
 - modifiers：一个包含修饰符的对象（如果有的话）。例如在 v-my-directive.foo.bar 中，修饰符对象是 { foo: true, bar: true }。
 - instance：使用该指令的组件实例。
 - dir：指令的定义对象。
vnode：代表绑定元素的底层VNode。
preNode：代表之前的渲染中指令所绑定元素的 VNode。仅在 beforeUpdate 和 updated 钩子中可用。
举例来说，像下面这样使用指令：
<div v-example:foo.bar="baz">
binding 参数会是一个这样的对象：
<script>
  {
    arg: 'foo',
    modifiers: { bar: true },
    value: /* `baz` 的值 */,
    oldValue: /* 上一次更新时 `baz` 的值 */
  }
</script>
和内置指令类似，自定义指令的参数也可以是动态的。举例来说：
<div v-example:[arg]="value"></div>
这里指令的参数会基于组件的 arg 数据属性响应式地更新。
Node：除了 el 外，其他参数都是只读的，不要更改它们。若你需要在不同的钩子间共享信息，推荐通过元素的 dataset attribute 实现。

## HTMLElement：dataset attribute
dataset接口的只读属性 提供HTMLElement对元素上的自定义数据属性 ( data-*) 的读/写访问。它公开了一个字符串映射 ( DOMStringMap)，其中每个data-*属性都有一个条目。

注意：该dataset属性本身可以读取，但不能直接写入。相反，所有写入都必须针对中的各个属性 dataset，而这些属性又代表数据属性。

HTMLdata-*属性及其相应的 DOM dataset.property根据读取或写入的位置修改它们的共享名称：

### 访问值
1.属性可以通过驼峰名称/键作为数据集的对象属性来设置和读取：element.dataset.keyname。
2.还可以使用括号语法设置和读取属性： element.dataset['keyname']。
3.操作in员可以检查给定属性是否存在： 'keyname' in element.dataset。

### 设定值
1.设置属性后，其值始终会转换为字符串。例如：element.dataset.example = null转换为data-example="null"。
2.要删除属性，您可以使用delete运算符: delete element.dataset.keyname。

<div id="user" data-id="1234567890" data-user="carinaanand" data-date-of-birth>
  Carina Anand
</div>

# 简化形式
对于自定义指令来说，一个很常见的情况是仅仅需要在 mounted 和 updated 上实现相同的行为，除此之外并不需要其他钩子。这种情况下我们可以直接用一个函数来定义指令，如下所示：
<div v-color="color"></div>
<script>
  app.directive('color', (el, binding) => {
    el.style.color = binding.value;
  });
</script>

# 对象字面量
如果你的指令需要多个值，你可以向它传递一个 JavaScript 对象字面量。别忘了，指令也可以接收任何合法的 JavaScript 表达式。
<div v-demo="{ color: 'white', text: 'hello!' }"></div>
<script>
  app.directive('demo', (el, binding) => {
    console.log(binding.value.color);// => "white"
    console.log(binding.value.text);// => "hello"
  })
</script>

# 在组件上使用
当在组件上使用自定义指令时，它会始终应用于组件的根节点，和透传 attributes 类似。
<MyComponent v-demo="test" />

## 透传Attributes
### Attributes继承
“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或者 v-on 事件监听器。最常见的例子就是 class、style 和 id。
当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上。
### 对class和style的合并
如果一个子组件的根元素已经有了 class 或 style attribute，它会和从父组件上继承的值合并。
### v-on监听器继承
click 监听器会被添加到 <MyButton> 的根元素，即那个原生的 <button> 元素之上。当原生的 <button> 被点击，会触发父组件的 onClick 方法。同样的，如果原生 button 元素自身也通过 v-on 绑定了一个事件监听器，则这个监听器和从父组件继承的监听器都会被触发。
### 深层组件继承
有些情况下一个组件会在根节点上渲染另一个组件。此时 <MyButton> 接收的透传 attribute 会直接继续传给 <BaseButton>。
请注意：
1.透传的 attribute 不会包含 <MyButton> 上声明过的 props 或是针对 emits 声明事件的 v-on 侦听函数，换句话说，声明过的 props 和侦听函数被 <MyButton>“消费”了。
2.透传的 attribute 若符合声明，也可以作为 props 传入 <BaseButton>。


